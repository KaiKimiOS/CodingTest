import UIKit
func solution(_ array:[Int]) -> Int {
    
    guard array.count != 1 else {return array[0]}
    //array.count 가 1이 아니면 아래 작업을 수행, 아니면 array[0]을 수행
    // 이 말은 배열이 [1,2,2,3,5,5,5,] 또는 [2] 라고 가정하였을때
    // 처음 배열은 array.count가 1이 아니기 때문에 아래 코드들을 이어서 수행한다
    //두번째 배열[2]는 .count가 1이기때문에 그대로 리턴한다는 뜻. 숫자가 하나이면 그 숫자를 리턴해야하기 때문에
    
    var dic: [Int: Int] = [:] // 빈 딕셔너리를 선언한다, 이 문제는 딕셔너리의 활용법 즉 키와 밸류 값을 아느냐가 관건이다
    
    
    for i in array {
        let count = dic[i] ?? 0
 
        dic[i] = count + 1
        
        // dic[i]가 무엇이냐? array가 [1,2,2,3,5,5,5] 일때
        // 배열 첫번째인 1이 i로 들어가면 dic[1]
        // 두번째 배열인 2가 i로 들어가면 dic[2]
        // 세번째 배열인 2가 i로 들어가면 그대로 dic[2] 이렇게 생각하면된다
        // 그리고 dic[i] ?? 0 은 옵셔널 바인딩에서 코얼레싱임. 즉 값이 있으면 그 값을 그대로, nil이면 0을 기본값으로 준다는 뜻
        // 그런데 왜 코얼레싱 해야 하는지 모르겠음. 왜 기본값을 줘야하는거지?
        
//        dic[i] = count + 1 // dic[1]의 value 값을 +1 해준다 생각하면되
    }
    
    let reDic = dic.sorted(by: {$0.1 > $1.1}) // 이걸 잘 모르겠는데, $0.1 > $1.1 이건 추후 공부해야할듯
    // 아무튼 딕셔너리를 sorted하는데 어떻게(by) 정렬할건지 하는거 같음. 내 생각엔 제일 많이 나온 순서가 맨위로 즉 5가 맨 위로 정렬
    
    return reDic[0].value == reDic[1].value ? -1 : reDic[0].key
    // 이건 만약 최빈값이 2개 일 수도 있으니까, 그러면 -1 리턴하고 아니면 reDic[0].Key 값 즉 배열에서 제일 많이 중복된 값을 리턴한다
}


solution([3,3,4,4,4])





